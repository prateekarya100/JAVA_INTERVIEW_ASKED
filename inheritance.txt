Superclass and Subclass:

Superclass (Parent Class): The class whose properties and methods are inherited.

Subclass (Child Class): The class that inherits the properties and methods from the superclass.

Types of Inheritance:

Single Inheritance: A subclass inherits from one superclass.

Multilevel Inheritance: A subclass inherits from another subclass.

Hierarchical Inheritance: Multiple subclasses inherit from one superclass.

Multiple Inheritance: Java does not support multiple inheritance of classes directly to avoid complexity and ambiguity, but it supports multiple inheritance through interfaces.

super Keyword:

Used to refer to the immediate parent class object.

Can be used to call parent class methods and constructors.

Method Overriding:

A subclass can provide a specific implementation for a method already defined in its superclass.

The @Override annotation is used to indicate that a method is being overridden.

Constructor Chaining:

When a subclass object is created, the constructor of the superclass is called first.

This ensures that the initialization process starts from the top of the hierarchy and moves down to the subclass.

Example: Animal Hierarchy
Let's illustrate inheritance with a simple example involving an Animal superclass and Dog and Cat subclasses.

Superclass: Animal
java
class Animal {
    String name;
    int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void eat() {
        System.out.println(name + " is eating.");
    }

    void sleep() {
        System.out.println(name + " is sleeping.");
    }
}
Subclass: Dog
java
class Dog extends Animal {
    String breed;

    public Dog(String name, int age, String breed) {
        super(name, age); // Calling the superclass constructor
        this.breed = breed;
    }

    void bark() {
        System.out.println(name + " is barking.");
    }

    @Override
    void eat() {
        super.eat(); // Calls the superclass method
        System.out.println(name + " is eating dog food.");
    }
}
Subclass: Cat
java
class Cat extends Animal {
    String color;

    public Cat(String name, int age, String color) {
        super(name, age); // Calling the superclass constructor
        this.color = color;
    }

    void meow() {
        System.out.println(name + " is meowing.");
    }

    @Override
    void eat() {
        super.eat(); // Calls the superclass method
        System.out.println(name + " is eating cat food.");
    }
}
Using the Classes
java
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("Buddy", 3, "Labrador");
        Cat myCat = new Cat("Whiskers", 2, "Black");

        myDog.eat();  // Output: Buddy is eating. Buddy is eating dog food.
        myDog.sleep(); // Output: Buddy is sleeping.
        myDog.bark(); // Output: Buddy is barking.

        myCat.eat();  // Output: Whiskers is eating. Whiskers is eating cat food.
        myCat.sleep(); // Output: Whiskers is sleeping.
        myCat.meow(); // Output: Whiskers is meowing.
    }
}
Explanation
Superclass (Animal):

Contains common attributes (name and age) and methods (eat and sleep).

A constructor initializes these attributes.

Subclass (Dog):

Inherits from Animal and adds a specific attribute (breed).

Provides its own method (bark).

Overrides the eat method to include additional behavior.

Subclass (Cat):

Inherits from Animal and adds a specific attribute (color).

Provides its own method (meow).

Overrides the eat method to include additional behavior.

Main Class:

Creates instances of Dog and Cat and calls their methods.

Demonstrates method overriding and the use of the super keyword.

Advantages of Inheritance
Code Reusability: Common functionality is defined once in the superclass and reused in subclasses.

Method Overriding: Allows subclasses to provide specific implementations while retaining the interface of the superclass.

Extensibility: New functionality can be added to the existing codebase by creating new subclasses without modifying existing classes.

Limitations and Considerations
Complexity: Deep inheritance hierarchies can become complex and difficult to manage.

Tight Coupling: Subclasses are tightly coupled to their superclasses, which can make the system less flexible.

Multiple Inheritance: Java does not support multiple inheritance of classes to avoid ambiguity and complexity. Multiple inheritance is achieved through interfaces.